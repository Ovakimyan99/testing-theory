# Структура unit теста

Чтобы делать простые и качественные тесты надо неукоснительно
следовать следующим правилам: AAA -
A - Arrange - Подготовка
A - Act - Выполнение
A - Assert - Проверка

Давайте представим приложение, где человек авторизуется на сайте.
Мы делаем аякс запрос и получаем какой-то результат.

И также у нас есть внешний модуль "Б", благодаря которому мы можем определить
является ли пользователь студентом.

Вот это все является частью подготовки. Мы готовим данные для того, чтобы
их потом можно было тестировать.

В фазу подготовки может входить:

- аякс запросы
- внешние модули | модуль`
- библиотеки
- входные данные
- выходные данные
- ...

В этой фазе подготовки мы занимаемся настройкой всего внешнего окружения модуля,
который мы тестируем. Как оно (внешнее окружение) должно себя вести во время
тестирования модуля.

И если с нашими данными что-то будет не так на этапе подготовки, то это будет
свидетельствовать о том, что что-то пошло не так и это не нарушает честности
наших тестов.

Мы будем знать, что это не этап выполнения и проблема не в написанных тестах.

Поэтому давайте представим, что в модуле "Б" у нас убрали метод isStudent, который
проверяет студент ли пользователь.

Тогда наш тест провалится, потому что модуль "Б" вызвал ошибку и модуль "А" (исходный)
тоже провалится, потому что зависит от "Б". Нарушает честность, верно?

Вот поэтому фаза подготовки отвечает за, как ни странно, подготовку окружения.
Таким образом, любые ошибки, которые возникают на этапе подготовки не являются
ошибками самого теста.

Во фреймворках они выводятся в отдельные фазы.

После подготовки мы переходим в фазу `выполнение`, где мы проверяем выполнение
тех операций, которые мы проверяем в этом тесте.

Выполнение может быть совсем простым. Например,
мы создаем модуль `foo`, то есть берем класс `foo`:

```js
// Выполнение:
const a = new Foo();
const r = a.getDiscount();
```

И тут, в этом коде, есть потенциальный источник ошибки.
Потому что в выполнении мы должны делать то, что мы тестируем.
А в этом небольшом фрагменте кода есть то, что относится к этапу подготовки.
Если в нашем модуле `foo` что-то сломается или изменится структура, чтобы
тест продолжал оставаться честным, мы должны знать, то это ошибка внешнего модуля,
а не нашего теста.

В общем и целом, это может быть простой вызов метода или визуальный компонент.
Но если это тестирование визуального компонента, к примеру

- найти кнопочку по селектору `.danger-btn`;
- .click - кликнуть по ней
- дождаться нашего фейкого аякс запроса (из этапа подготовки)

И важно, чтобы на этапе выполнения шагов было мало, чтобы тест оставался честным.

И после этого фаза `проверка`.
Это просто мы говорим, что при таких входных данных мы хотим вернуть наш `r = 20%`.

И есть 4 фаза, про которую мы умолчали, -- `очистка`. О ней мы поговорим, когда будем
заниматься имплементацией тестов.

---
При этом хочу обратить ваше внимание на то, что часто нарушается в идеальном мире,
когда наш тест выглядит так:

1. Мы подготавливаем какие-то данные | Arrange
2. Выполняем действие | Act
3. Проверяем | Assert
4. Выполняем действие | Act
5. Проверяем | Assert

К примеру, как это может быть?
Представим себе банальный список из чекбоксов.
И мы отображаем `x` выбранных элементов (кол-во)

Как может выглядеть наш тест:  

```md
Подготовка:
Настраиваем список, например, из 3-х элементов.
Делаем Ajax запрос

Акт:
Клик по 1 элементу

Проверка:
Выбран 1 элемент

Акт:
Клик по 1 элементу

Проверка:
Выбрано 0 элементов
```

И вот этот тест нарушает все то, что мы обсуждали ранее.
И в идеальном мире у нас должно быть 2 теста.

Первый тест:

```md
Подготовка:
Настраиваем список, например, из 3-х элементов.
Делаем Ajax запрос

Акт:
Клик по 1 элементу

Проверка:
Выбран 1 элемент
```

И второй тест, где клик по первому элементу должен быть вынесен в фазу
`arrange`!

То есть граница подготовки второго теста соответствует окончанию выполнения
акта первого.

```md
Подготовка:
Тест 1 (`
    Подготовка:
    Настраиваем список, например, из 3-х элементов.
    Делаем Ajax запрос
    
    Акт:
    Клик по 1 элементу
`)

Акт / Выполнение:
Клик по первому элементу

Проверка:
Выбрано 0 элементов
```

Грубо говоря, зачем это нужно?
Если мы сломали выбор элемента, но не его 'deselect', тогда:

Первый тест отвечает за то, что мы проверяем корректность выбора.
А второй тест за то, что мы проверяем корректность анти-выбора.

И тогда, если у нас проблемы с выбором, то первый тест сломается в фазе проверки,
а второй тест сломается на фазе подготовки.

---
Вообще, самое главное, чтобы после фазы `Act` не выполнялась фаза `Arrange`
еще раз.
