# Задачи unit тестирования

Если ранее мы говорили о том, когда надо unit тестирование, то сейчас мы попробуем
ответить на вопрос, а каковы задачи unit тестирования?

С чего начинается наша работа? Она начинается с требований.
Каждые требования мы стараемся формализовать, в связи с чем мы для них
разрабатываем модули.

Потом мы наши труды проверяют QA или E2E тесты, чтобы они совпадали с требованиями.
Также мы ведем инженерную документацию, где описываем обычными человеческими словами
наш код. Но кто гарантирует, что последующее изменение в коде не затронет и не изменит
что в поведении, что не будет соответствовать этой документации?

Тогда все, до свидания. Именно поэтому
Unit тесты функционируют как инструмент описания бизнес требований к модулю.

Давайте предположим, что после определенной разработки функционала вы решили сделать
рефакторинг? Как нам понять, что новый изящный, чистый код работает так же, как раньше и
ничего не сломалось?

Тесты.

Если мы не будем реализовывать тесты в рамках одной задачи, а в рамках двух,
то так получится, что мы будем ее вечно откладывать, тк тесты в короткосроке
имеют меньшую ценность и так мы рискуем сделать тесты приблизительно никогда.
И так же мы теряем возможность документировать наш код. Если этого не происходит,
то мы не сможем в будущем понять, было ли странное поведение задумано и является
ли это осознанным выбором.

Bus factor - с позиции бизнеса иметь незаменимого человека крайне рискованно.
Поэтому unit тесты помогают разобраться, как работает каждый отельный узел системы.

Резюмируем:

1. Unit тесты осуществляют очень важную задачу документирования конкретного узла системы
2. Позволяет задекларировать, что вы думаете.
3. С другой стороны автоматически проконтролировать, что в результате изменений не сломалось то,
что думали предыдущие программисты
4. И самое главное, когда тест становится красным, это позволяет не бегать по всей системе, а
сказать "в этом файлике что-то пошло не так"
5. Самое главное: unit тесты должно быть легко писать, чтобы о них можно было легко думать.

Если тест сложно писать, то это говорит о том, что архитектура системы несколько хромает и
если это сложно понимать в тесте, получается и саму систему сложно понять. Вероятно архитектуру
следует упрощать

Потому что если проекты хотят выжить, то bus factor этого приложения должен быть максимально далек от 1.
