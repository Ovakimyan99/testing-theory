# Framework для тестирования

Теперь, когда мы многое разобрали, надо понять, а нужен ли нам фреймворк и что
нам дают существующие фреймворки.

Для этого надо вернуться в наши неукоснительным правилам тестирования:
A - Arrange
A - Act
A - Assert

Во время фазы `Act` все просто и понятно, мы исполняем наш код.
Во время фазы Assert нам надо как-то описать и дать то, что мы хотим
получить на выходе.

Например, мы можем сделать так:

```js
[...].map(...).every(...).contain(...)
```

И пытаться объяснить что-то, что мы хотим получить. Но тесты должны легко читаться.
Это достаточно важное условие. Поэтому фреймворк нам предоставляет такой синтаксис:

```js
expect(res).toContain([...]);
```

И это очень похоже на человекоподобный синтаксис.

Самой распространенной библиотекой реализации проверок является chai.
Это библиотека проверок для фреймворка тестирования под названием mocha.

---
Также у нас фаза Arrange.
Нам нужен инструмент, позволяющий создавать наши заглушки
Mock, Stub, Spy...

Для этого используется библиотека sinon. Также можно познакомиться с понятием
testDouble.

Что нам еще надо от Arrange?
Как мы устанавливаем связь между модулями?
Это банально путем использования import или required(node).

И нам ведь надо научиться заменять реализацию модуля 'Б' на Mock модуля Б.
И этим занимается `Rewire`, потому что import статичны и замена одних
данных на другие дело нетривиальное. / как то так, я пока не до конца улавливаю
почему

И также немаловажной частью является Runner.
Это штука, которая наши тесты запускает. Почему?
Мы хотим, чтобы наши тесты выполнялись быстро, соответственно их надо

1. Parallel
2. isolation
3. filter - запускать подмножество тестов
4. "плюшки"
4.1 Какие виды плюшек? Например, watch mode, который перезапускал бы только нужны
тесты.
4.2 coverage - знать, какие строчки кода тестов запускались.
4.3 "интеллект" - запускает первоочередно те тесты, которые провалились после обновления.
5. Отчеты / в html, json, xml

И помимо этого есть Utility.
Сейчас, если кратко, это

1. Настройка окружения
2. Предоставить механизмы отладки тестов
3. "Сборка"
4. "Магия" - это далее

Вопрос:
Почему следует изучать jest, а не что-то другое?

Потому что, когда мы пишем тесты, хочется чтобы все элементы системы четко
подходили друг другу.

Но вместо одного инструмента, мы можем использовать, например, вот эти:

1. ava / mocha
2. chai
3. sinon
4. rewire

И это надо умудриться настроить для корректной работы друг с другом. А Jest
предоставляет все это вместе.
