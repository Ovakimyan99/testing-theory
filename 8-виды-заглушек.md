# Виды заглушек

Ранее мы говорили о том, что нам надо конструировать "нечто", которые будут
заменять нам реальные модули.

Пришло время узнать, как апологеты тестирования называют эти заглушки и каких
видов они бывают.

Начнем с самого простого:

1. Dummy
Dummy заглушка - это заглушка, которая не имеет вообще никакой логики и данных.

Если в каких-то тестах нам нужна Dummy заглушка, то в других требует что-то
посерьезнее. Например:

2. Fake
Он содержит в себе упрощенную логику объекта, которую он замещает, но эта логика
является полноценной и написана не нами.

3. Stub - заглушка
Она содержит просто набор правил. На определенные входные данные он выдает
определенный ответ. Stub гарантирует, то ничего никогда не сломается.

4. Spies - шпион
Фаулер определяет шпиона, как некий метод, который кроме всего прочего сохраняет
еще и какую-то информацию.

Spies вообще не перехватывает управление. Он только в процессе может через себя
пропустить. И в этот момент мы можем какие-то данные перехватить, проверить.

5. Mocks
Она содержит ожидания того, с какими параметрами она будет вызвана.
И если, не дай Бог, она будет вызвана с другими параметрами, то это приведет
к провалу теста.

А теперь хороший вопрос, когда у нас вызываются стабы, а когда моки?
Моки больше похожи на пропсы, а стабы на данные, которые мы получаем с сервера
во время деструктуризации. Хотя тут как раз тонкая грань, которая в моем примере
стерта.

В реальности, в 90% времени мы будем работать со Stub и Spies.
И из этого мы 80% времени мы будем стабать, а 20% спаить.

Если спаев становится больше, то надо задуматься, а не знает ли наш код
слишком много? И тогда тест может становиться слишком хрупким.

---
Поговорим о Stub.
Они прекрасны тем, что гарантируют, что наш модуль не сломается, когда сломаются
другие модули.

Но есть 1 проблема, с которой мы столкнемся всегда и она будет вечной.
Как нам гарантировать, что те ответы stub, что мы запрограммировали в своем
тесте, будут сочетаться с теми объектами, которые дает реальный объект?

Например, исходно наш стаб отвечал так:

```js
[{id: 1}, {id: ..}]
```

А после рефакторинга он начал отвечать так:

```js
[1, 3, 14, ...]
```

Ваши тесты модуля продолжат оставаться зелеными, потому что здесь будет старый
stub. ... Короче, я не до конца понимаю, о чем тут говорит Илья. Мне сложно
это объяснить. Надо на практике столкнуться.

Но неким решением из ситуации становится типизация, которая не всегда нам все
гарантирует.

И также во фреймворка есть рантайм проверка пропсов.
